package utils;

import exceptions.HashMapCollisionException;

public class HashMap<K, V> {
    private Entry<K, V>[] map;
    private int count;

    public HashMap(){
        // Create an array of Entry objects - don't need to specify the type
        // as it's specified when declared above
        map = new Entry [103];
        count = 0;
    }



    public V put(K key, V value){
        // Validation
        if(key == null){
            throw new IllegalArgumentException("Key cannot be null");
        }
        // Calculate appropriate slot/bucket for use based on key
        int pos = hashPosition(key);

        // Get current data in calculated slot
        Entry<K,V> entry = map[pos];
        // If slot/bucket is not empty, check if it has our key
        if(entry != null){
            // If it doesn't have our key, throw a collision exception
            if(!entry.key.equals(key)){
                throw new HashMapCollisionException("Position generated by key \"" + key + "\" collides with existing" +
                        " key " +
                        "in map");
            }

            // If it has the same key, swap out the values and return old one
            V oldValue = entry.value;
            entry.value = value;
            return oldValue;
        }

        // No data in the bucket already, create a new Entry
        // and add the key and value
        Entry<K, V> newEntry = new Entry<>(key, value);
        map[pos] = newEntry;
        count++;
        // Return nothing as nothing was replaced
        return null;
    }

    private int hashPosition(K key) {
        if(key == null){
            throw new IllegalArgumentException("Key cannot be null");
        }
        return Math.abs(key.hashCode()) % map.length;
    }

    private static class Entry<K, V>{
        K key;
        V value;

        public Entry(K key, V value){
            this.key = key;
            this.value = value;
        }
    }
}
